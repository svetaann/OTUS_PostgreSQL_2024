# Блокировки
## Домашнее задание
1. Настройте сервер так, чтобы в журнал сообщений сбрасывалась информация о блокировках, удерживаемых более 200 миллисекунд. Воспроизведите ситуацию, при которой в журнале появятся такие сообщения.
```
log_lock_waits = on
deadlock_timeout = 200ms
```
> с 3 сессий заупщена команда
```
BEGIN;
UPDATE test_table SET data = 'updated by session 1' WHERE id = 1;
```
```
2024-12-24 18:58:17.303 MSK [651076] postgres@hw7 LOG:  process 651076 still waiting for ShareLock on transaction 738 after 200.232 ms
2024-12-24 18:58:17.303 MSK [651076] postgres@hw7 DETAIL:  Process holding the lock: 651075. Wait queue: 651076.
2024-12-24 18:58:17.303 MSK [651076] postgres@hw7 CONTEXT:  while updating tuple (0,1) in relation "test_table"
2024-12-24 18:58:17.303 MSK [651076] postgres@hw7 STATEMENT:  UPDATE test_table SET data = 'updated by session 2' WHERE id = 1;
2024-12-24 18:58:21.173 MSK [651077] postgres@hw7 LOG:  process 651077 still waiting for ExclusiveLock on tuple (0,1) of relation 16390 of database 16388 >
2024-12-24 18:58:21.173 MSK [651077] postgres@hw7 DETAIL:  Process holding the lock: 651076. Wait queue: 651077.
2024-12-24 18:58:21.173 MSK [651077] postgres@hw7 STATEMENT:  UPDATE test_table SET data = 'updated by session 3' WHERE id = 1;
2024-12-24 18:58:45.936 MSK [651076] postgres@hw7 LOG:  process 651076 acquired ShareLock on transaction 738 after 28832.774 ms
2024-12-24 18:58:45.936 MSK [651076] postgres@hw7 CONTEXT:  while updating tuple (0,1) in relation "test_table"
2024-12-24 18:58:45.936 MSK [651076] postgres@hw7 STATEMENT:  UPDATE test_table SET data = 'updated by session 2' WHERE id = 1;
2024-12-24 18:58:45.936 MSK [651077] postgres@hw7 LOG:  process 651077 acquired ExclusiveLock on tuple (0,1) of relation 16390 of database 16388 after 249>
2024-12-24 18:58:45.936 MSK [651077] postgres@hw7 STATEMENT:  UPDATE test_table SET data = 'updated by session 3' WHERE id = 1;
2024-12-24 18:58:46.137 MSK [651077] postgres@hw7 LOG:  process 651077 still waiting for ShareLock on transaction 739 after 200.177 ms
2024-12-24 18:58:46.137 MSK [651077] postgres@hw7 DETAIL:  Process holding the lock: 651076. Wait queue: 651077.
2024-12-24 18:58:46.137 MSK [651077] postgres@hw7 CONTEXT:  while updating tuple (0,1) in relation "test_table"
2024-12-24 18:58:46.137 MSK [651077] postgres@hw7 STATEMENT:  UPDATE test_table SET data = 'updated by session 3' WHERE id = 1;
```
2. Смоделируйте ситуацию обновления одной и той же строки тремя командами UPDATE в разных сеансах. Изучите возникшие блокировки в представлении pg_locks и убедитесь, что все они понятны. Пришлите список блокировок и объясните, что значит каждая.
```
 locktype | database | relation | page | tuple | virtualxid | transactionid | classid | objid | objsubid | virtualtransaction |  pid   |       mode       | granted | fastpath | waitstart
----------+----------+----------+------+-------+------------+---------------+---------+-------+----------+--------------------+--------+------------------+---------+----------+-----------
 relation |    16388 |    16390 |      |       |            |               |         |       |          | 6/22               | 651131 | RowExclusiveLock | t       | t        |
 relation |    16388 |    16390 |      |       |            |               |         |       |          | 3/15               | 651076 | RowExclusiveLock | t       | t        |
 tuple    |    16388 |    16390 |    0 |     1 |            |               |         |       |          | 6/22               | 651131 | ExclusiveLock    | t       | f        |
(3 rows)

```
>RowExclusiveLock: Блокировка на уровне строки для изменений
>
>ExclusiveLock: Запрос доступа к ресурсу, предотвращающий другие модификации
3. Воспроизведите взаимоблокировку трех транзкций. Можно ли разобраться в ситуации постфактум, изучая журнал сообщений?
```
2024-12-24 19:10:45.721 MSK [651163] postgres@hw7 STATEMENT:  UPDATE deadlock_test SET data = 'A' WHERE id = 2;
2024-12-24 19:10:47.731 MSK [651167] postgres@hw7 LOG:  process 651167 still waiting for ShareLock on transaction 749 after 200.235 ms
2024-12-24 19:10:47.731 MSK [651167] postgres@hw7 DETAIL:  Process holding the lock: 651171. Wait queue: 651167.
2024-12-24 19:10:47.731 MSK [651167] postgres@hw7 CONTEXT:  while updating tuple (0,3) in relation "deadlock_test"
2024-12-24 19:10:47.731 MSK [651167] postgres@hw7 STATEMENT:  UPDATE deadlock_test SET data = 'B' WHERE id = 3;
2024-12-24 19:10:49.726 MSK [651171] postgres@hw7 LOG:  process 651171 detected deadlock while waiting for ShareLock on transaction 747 after 200.206 ms
2024-12-24 19:10:49.726 MSK [651171] postgres@hw7 DETAIL:  Process holding the lock: 651163. Wait queue: .
2024-12-24 19:10:49.726 MSK [651171] postgres@hw7 CONTEXT:  while updating tuple (0,1) in relation "deadlock_test"
2024-12-24 19:10:49.726 MSK [651171] postgres@hw7 STATEMENT:  UPDATE deadlock_test SET data = 'C' WHERE id = 1;
2024-12-24 19:10:49.726 MSK [651171] postgres@hw7 ERROR:  deadlock detected
2024-12-24 19:10:49.726 MSK [651171] postgres@hw7 DETAIL:  Process 651171 waits for ShareLock on transaction 747; blocked by process 651163.
        Process 651163 waits for ShareLock on transaction 748; blocked by process 651167.
        Process 651167 waits for ShareLock on transaction 749; blocked by process 651171.
        Process 651171: UPDATE deadlock_test SET data = 'C' WHERE id = 1;
        Process 651163: UPDATE deadlock_test SET data = 'A' WHERE id = 2;
        Process 651167: UPDATE deadlock_test SET data = 'B' WHERE id = 3;
2024-12-24 19:10:49.726 MSK [651171] postgres@hw7 HINT:  See server log for query details.
2024-12-24 19:10:49.726 MSK [651171] postgres@hw7 CONTEXT:  while updating tuple (0,1) in relation "deadlock_test"
2024-12-24 19:10:49.726 MSK [651171] postgres@hw7 STATEMENT:  UPDATE deadlock_test SET data = 'C' WHERE id = 1;
2024-12-24 19:10:49.726 MSK [651167] postgres@hw7 LOG:  process 651167 acquired ShareLock on transaction 749 after 2196.005 ms
2024-12-24 19:10:49.726 MSK [651167] postgres@hw7 CONTEXT:  while updating tuple (0,3) in relation "deadlock_test"
2024-12-24 19:10:49.726 MSK [651167] postgres@hw7 STATEMENT:  UPDATE deadlock_test SET data = 'B' WHERE id = 3;
```
4. Могут ли две транзакции, выполняющие единственную команду UPDATE одной и той же таблицы (без where), заблокировать друг друга?

> Да, если одна транзакция частично обновила строки, а другая ожидает блокировки

### Задание со звездочкой*
Попробуйте воспроизвести такую ситуацию.
> Создадим таблицу
```
CREATE TABLE test_deadlock (
    id SERIAL PRIMARY KEY,
    data TEXT
);
INSERT INTO test_deadlock (data) VALUES ('row1'), ('row2');
```
> c каждого из сеансов
```
BEGIN;
UPDATE test_deadlock SET data = 'updated1';
```
```
2024-12-24 19:14:34.048 MSK [651226] postgres@hw7 LOG:  process 651226 still waiting for ShareLock on transaction 752 after 200.236 ms
2024-12-24 19:14:34.048 MSK [651226] postgres@hw7 DETAIL:  Process holding the lock: 651210. Wait queue: 651226.
2024-12-24 19:14:34.048 MSK [651226] postgres@hw7 CONTEXT:  while updating tuple (0,1) in relation "test_deadlock"
2024-12-24 19:14:34.048 MSK [651226] postgres@hw7 STATEMENT:  UPDATE test_deadlock SET data = 'updated2';
```
